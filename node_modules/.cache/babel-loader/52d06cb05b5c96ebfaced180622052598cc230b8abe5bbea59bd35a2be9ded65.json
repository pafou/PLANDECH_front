{"ast":null,"code":"'use strict';\n\n///@ts-check\nimport { getAllMatches, isExist } from '../util.js';\nimport xmlNode from './xmlNode.js';\nimport DocTypeReader from './DocTypeReader.js';\nimport toNumber from \"strnum\";\nimport getIgnoreAttributesFn from \"../ignoreAttributes.js\";\n\n// const regx =\n//   '<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\\\/)(NAME)\\\\s*>))([^<]*)'\n//   .replace(/NAME/g, util.nameRegexp);\n\n//const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\n\nexport default class OrderedObjParser {\n  constructor(options) {\n    this.options = options;\n    this.currentNode = null;\n    this.tagsNodeStack = [];\n    this.docTypeEntities = {};\n    this.lastEntities = {\n      \"apos\": {\n        regex: /&(apos|#39|#x27);/g,\n        val: \"'\"\n      },\n      \"gt\": {\n        regex: /&(gt|#62|#x3E);/g,\n        val: \">\"\n      },\n      \"lt\": {\n        regex: /&(lt|#60|#x3C);/g,\n        val: \"<\"\n      },\n      \"quot\": {\n        regex: /&(quot|#34|#x22);/g,\n        val: \"\\\"\"\n      }\n    };\n    this.ampEntity = {\n      regex: /&(amp|#38|#x26);/g,\n      val: \"&\"\n    };\n    this.htmlEntities = {\n      \"space\": {\n        regex: /&(nbsp|#160);/g,\n        val: \" \"\n      },\n      // \"lt\" : { regex: /&(lt|#60);/g, val: \"<\" },\n      // \"gt\" : { regex: /&(gt|#62);/g, val: \">\" },\n      // \"amp\" : { regex: /&(amp|#38);/g, val: \"&\" },\n      // \"quot\" : { regex: /&(quot|#34);/g, val: \"\\\"\" },\n      // \"apos\" : { regex: /&(apos|#39);/g, val: \"'\" },\n      \"cent\": {\n        regex: /&(cent|#162);/g,\n        val: \"¢\"\n      },\n      \"pound\": {\n        regex: /&(pound|#163);/g,\n        val: \"£\"\n      },\n      \"yen\": {\n        regex: /&(yen|#165);/g,\n        val: \"¥\"\n      },\n      \"euro\": {\n        regex: /&(euro|#8364);/g,\n        val: \"€\"\n      },\n      \"copyright\": {\n        regex: /&(copy|#169);/g,\n        val: \"©\"\n      },\n      \"reg\": {\n        regex: /&(reg|#174);/g,\n        val: \"®\"\n      },\n      \"inr\": {\n        regex: /&(inr|#8377);/g,\n        val: \"₹\"\n      },\n      \"num_dec\": {\n        regex: /&#([0-9]{1,7});/g,\n        val: (_, str) => String.fromCodePoint(Number.parseInt(str, 10))\n      },\n      \"num_hex\": {\n        regex: /&#x([0-9a-fA-F]{1,6});/g,\n        val: (_, str) => String.fromCodePoint(Number.parseInt(str, 16))\n      }\n    };\n    this.addExternalEntities = addExternalEntities;\n    this.parseXml = parseXml;\n    this.parseTextData = parseTextData;\n    this.resolveNameSpace = resolveNameSpace;\n    this.buildAttributesMap = buildAttributesMap;\n    this.isItStopNode = isItStopNode;\n    this.replaceEntitiesValue = replaceEntitiesValue;\n    this.readStopNodeData = readStopNodeData;\n    this.saveTextToParentTag = saveTextToParentTag;\n    this.addChild = addChild;\n    this.ignoreAttributesFn = getIgnoreAttributesFn(this.options.ignoreAttributes);\n    if (this.options.stopNodes && this.options.stopNodes.length > 0) {\n      this.stopNodesExact = new Set();\n      this.stopNodesWildcard = new Set();\n      for (let i = 0; i < this.options.stopNodes.length; i++) {\n        const stopNodeExp = this.options.stopNodes[i];\n        if (typeof stopNodeExp !== 'string') continue;\n        if (stopNodeExp.startsWith(\"*.\")) {\n          this.stopNodesWildcard.add(stopNodeExp.substring(2));\n        } else {\n          this.stopNodesExact.add(stopNodeExp);\n        }\n      }\n    }\n  }\n}\nfunction addExternalEntities(externalEntities) {\n  const entKeys = Object.keys(externalEntities);\n  for (let i = 0; i < entKeys.length; i++) {\n    const ent = entKeys[i];\n    this.lastEntities[ent] = {\n      regex: new RegExp(\"&\" + ent + \";\", \"g\"),\n      val: externalEntities[ent]\n    };\n  }\n}\n\n/**\n * @param {string} val\n * @param {string} tagName\n * @param {string} jPath\n * @param {boolean} dontTrim\n * @param {boolean} hasAttributes\n * @param {boolean} isLeafNode\n * @param {boolean} escapeEntities\n */\nfunction parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {\n  if (val !== undefined) {\n    if (this.options.trimValues && !dontTrim) {\n      val = val.trim();\n    }\n    if (val.length > 0) {\n      if (!escapeEntities) val = this.replaceEntitiesValue(val);\n      const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);\n      if (newval === null || newval === undefined) {\n        //don't parse\n        return val;\n      } else if (typeof newval !== typeof val || newval !== val) {\n        //overwrite\n        return newval;\n      } else if (this.options.trimValues) {\n        return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n      } else {\n        const trimmedVal = val.trim();\n        if (trimmedVal === val) {\n          return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n        } else {\n          return val;\n        }\n      }\n    }\n  }\n}\nfunction resolveNameSpace(tagname) {\n  if (this.options.removeNSPrefix) {\n    const tags = tagname.split(':');\n    const prefix = tagname.charAt(0) === '/' ? '/' : '';\n    if (tags[0] === 'xmlns') {\n      return '';\n    }\n    if (tags.length === 2) {\n      tagname = prefix + tags[1];\n    }\n  }\n  return tagname;\n}\n\n//TODO: change regex to capture NS\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\nconst attrsRegx = new RegExp('([^\\\\s=]+)\\\\s*(=\\\\s*([\\'\"])([\\\\s\\\\S]*?)\\\\3)?', 'gm');\nfunction buildAttributesMap(attrStr, jPath, tagName) {\n  if (this.options.ignoreAttributes !== true && typeof attrStr === 'string') {\n    // attrStr = attrStr.replace(/\\r?\\n/g, ' ');\n    //attrStr = attrStr || attrStr.trim();\n\n    const matches = getAllMatches(attrStr, attrsRegx);\n    const len = matches.length; //don't make it inline\n    const attrs = {};\n    for (let i = 0; i < len; i++) {\n      const attrName = this.resolveNameSpace(matches[i][1]);\n      if (this.ignoreAttributesFn(attrName, jPath)) {\n        continue;\n      }\n      let oldVal = matches[i][4];\n      let aName = this.options.attributeNamePrefix + attrName;\n      if (attrName.length) {\n        if (this.options.transformAttributeName) {\n          aName = this.options.transformAttributeName(aName);\n        }\n        if (aName === \"__proto__\") aName = \"#__proto__\";\n        if (oldVal !== undefined) {\n          if (this.options.trimValues) {\n            oldVal = oldVal.trim();\n          }\n          oldVal = this.replaceEntitiesValue(oldVal);\n          const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);\n          if (newVal === null || newVal === undefined) {\n            //don't parse\n            attrs[aName] = oldVal;\n          } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {\n            //overwrite\n            attrs[aName] = newVal;\n          } else {\n            //parse\n            attrs[aName] = parseValue(oldVal, this.options.parseAttributeValue, this.options.numberParseOptions);\n          }\n        } else if (this.options.allowBooleanAttributes) {\n          attrs[aName] = true;\n        }\n      }\n    }\n    if (!Object.keys(attrs).length) {\n      return;\n    }\n    if (this.options.attributesGroupName) {\n      const attrCollection = {};\n      attrCollection[this.options.attributesGroupName] = attrs;\n      return attrCollection;\n    }\n    return attrs;\n  }\n}\nconst parseXml = function (xmlData) {\n  xmlData = xmlData.replace(/\\r\\n?/g, \"\\n\"); //TODO: remove this line\n  const xmlObj = new xmlNode('!xml');\n  let currentNode = xmlObj;\n  let textData = \"\";\n  let jPath = \"\";\n  const docTypeReader = new DocTypeReader(this.options.processEntities);\n  for (let i = 0; i < xmlData.length; i++) {\n    //for each char in XML data\n    const ch = xmlData[i];\n    if (ch === '<') {\n      // const nextIndex = i+1;\n      // const _2ndChar = xmlData[nextIndex];\n      if (xmlData[i + 1] === '/') {\n        //Closing Tag\n        const closeIndex = findClosingIndex(xmlData, \">\", i, \"Closing Tag is not closed.\");\n        let tagName = xmlData.substring(i + 2, closeIndex).trim();\n        if (this.options.removeNSPrefix) {\n          const colonIndex = tagName.indexOf(\":\");\n          if (colonIndex !== -1) {\n            tagName = tagName.substr(colonIndex + 1);\n          }\n        }\n        if (this.options.transformTagName) {\n          tagName = this.options.transformTagName(tagName);\n        }\n        if (currentNode) {\n          textData = this.saveTextToParentTag(textData, currentNode, jPath);\n        }\n\n        //check if last tag of nested tag was unpaired tag\n        const lastTagName = jPath.substring(jPath.lastIndexOf(\".\") + 1);\n        if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {\n          throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);\n        }\n        let propIndex = 0;\n        if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {\n          propIndex = jPath.lastIndexOf('.', jPath.lastIndexOf('.') - 1);\n          this.tagsNodeStack.pop();\n        } else {\n          propIndex = jPath.lastIndexOf(\".\");\n        }\n        jPath = jPath.substring(0, propIndex);\n        currentNode = this.tagsNodeStack.pop(); //avoid recursion, set the parent tag scope\n        textData = \"\";\n        i = closeIndex;\n      } else if (xmlData[i + 1] === '?') {\n        let tagData = readTagExp(xmlData, i, false, \"?>\");\n        if (!tagData) throw new Error(\"Pi Tag is not closed.\");\n        textData = this.saveTextToParentTag(textData, currentNode, jPath);\n        if (this.options.ignoreDeclaration && tagData.tagName === \"?xml\" || this.options.ignorePiTags) {} else {\n          const childNode = new xmlNode(tagData.tagName);\n          childNode.add(this.options.textNodeName, \"\");\n          if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {\n            childNode[\":@\"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);\n          }\n          this.addChild(currentNode, childNode, jPath, i);\n        }\n        i = tagData.closeIndex + 1;\n      } else if (xmlData.substr(i + 1, 3) === '!--') {\n        const endIndex = findClosingIndex(xmlData, \"-->\", i + 4, \"Comment is not closed.\");\n        if (this.options.commentPropName) {\n          const comment = xmlData.substring(i + 4, endIndex - 2);\n          textData = this.saveTextToParentTag(textData, currentNode, jPath);\n          currentNode.add(this.options.commentPropName, [{\n            [this.options.textNodeName]: comment\n          }]);\n        }\n        i = endIndex;\n      } else if (xmlData.substr(i + 1, 2) === '!D') {\n        const result = docTypeReader.readDocType(xmlData, i);\n        this.docTypeEntities = result.entities;\n        i = result.i;\n      } else if (xmlData.substr(i + 1, 2) === '![') {\n        const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"CDATA is not closed.\") - 2;\n        const tagExp = xmlData.substring(i + 9, closeIndex);\n        textData = this.saveTextToParentTag(textData, currentNode, jPath);\n        let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);\n        if (val == undefined) val = \"\";\n\n        //cdata should be set even if it is 0 length string\n        if (this.options.cdataPropName) {\n          currentNode.add(this.options.cdataPropName, [{\n            [this.options.textNodeName]: tagExp\n          }]);\n        } else {\n          currentNode.add(this.options.textNodeName, val);\n        }\n        i = closeIndex + 2;\n      } else {\n        //Opening tag\n        let result = readTagExp(xmlData, i, this.options.removeNSPrefix);\n        let tagName = result.tagName;\n        const rawTagName = result.rawTagName;\n        let tagExp = result.tagExp;\n        let attrExpPresent = result.attrExpPresent;\n        let closeIndex = result.closeIndex;\n        if (this.options.transformTagName) {\n          tagName = this.options.transformTagName(tagName);\n        }\n\n        //save text as child node\n        if (currentNode && textData) {\n          if (currentNode.tagname !== '!xml') {\n            //when nested tag is found\n            textData = this.saveTextToParentTag(textData, currentNode, jPath, false);\n          }\n        }\n\n        //check if last tag was unpaired tag\n        const lastTag = currentNode;\n        if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {\n          currentNode = this.tagsNodeStack.pop();\n          jPath = jPath.substring(0, jPath.lastIndexOf(\".\"));\n        }\n        if (tagName !== xmlObj.tagname) {\n          jPath += jPath ? \".\" + tagName : tagName;\n        }\n        const startIndex = i;\n        if (this.isItStopNode(this.stopNodesExact, this.stopNodesWildcard, jPath, tagName)) {\n          let tagContent = \"\";\n          //self-closing tag\n          if (tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1) {\n            if (tagName[tagName.length - 1] === \"/\") {\n              //remove trailing '/'\n              tagName = tagName.substr(0, tagName.length - 1);\n              jPath = jPath.substr(0, jPath.length - 1);\n              tagExp = tagName;\n            } else {\n              tagExp = tagExp.substr(0, tagExp.length - 1);\n            }\n            i = result.closeIndex;\n          }\n          //unpaired tag\n          else if (this.options.unpairedTags.indexOf(tagName) !== -1) {\n            i = result.closeIndex;\n          }\n          //normal tag\n          else {\n            //read until closing tag is found\n            const result = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);\n            if (!result) throw new Error(`Unexpected end of ${rawTagName}`);\n            i = result.i;\n            tagContent = result.tagContent;\n          }\n          const childNode = new xmlNode(tagName);\n          if (tagName !== tagExp && attrExpPresent) {\n            childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n          }\n          if (tagContent) {\n            tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);\n          }\n          jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n          childNode.add(this.options.textNodeName, tagContent);\n          this.addChild(currentNode, childNode, jPath, startIndex);\n        } else {\n          //selfClosing tag\n          if (tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1) {\n            if (tagName[tagName.length - 1] === \"/\") {\n              //remove trailing '/'\n              tagName = tagName.substr(0, tagName.length - 1);\n              jPath = jPath.substr(0, jPath.length - 1);\n              tagExp = tagName;\n            } else {\n              tagExp = tagExp.substr(0, tagExp.length - 1);\n            }\n            if (this.options.transformTagName) {\n              tagName = this.options.transformTagName(tagName);\n            }\n            const childNode = new xmlNode(tagName);\n            if (tagName !== tagExp && attrExpPresent) {\n              childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n            }\n            this.addChild(currentNode, childNode, jPath, startIndex);\n            jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n          }\n          //opening tag\n          else {\n            const childNode = new xmlNode(tagName);\n            this.tagsNodeStack.push(currentNode);\n            if (tagName !== tagExp && attrExpPresent) {\n              childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n            }\n            this.addChild(currentNode, childNode, jPath, startIndex);\n            currentNode = childNode;\n          }\n          textData = \"\";\n          i = closeIndex;\n        }\n      }\n    } else {\n      textData += xmlData[i];\n    }\n  }\n  return xmlObj.child;\n};\nfunction addChild(currentNode, childNode, jPath, startIndex) {\n  // unset startIndex if not requested\n  if (!this.options.captureMetaData) startIndex = undefined;\n  const result = this.options.updateTag(childNode.tagname, jPath, childNode[\":@\"]);\n  if (result === false) {} else if (typeof result === \"string\") {\n    childNode.tagname = result;\n    currentNode.addChild(childNode, startIndex);\n  } else {\n    currentNode.addChild(childNode, startIndex);\n  }\n}\nconst replaceEntitiesValue = function (val) {\n  if (this.options.processEntities) {\n    for (let entityName in this.docTypeEntities) {\n      const entity = this.docTypeEntities[entityName];\n      val = val.replace(entity.regx, entity.val);\n    }\n    for (let entityName in this.lastEntities) {\n      const entity = this.lastEntities[entityName];\n      val = val.replace(entity.regex, entity.val);\n    }\n    if (this.options.htmlEntities) {\n      for (let entityName in this.htmlEntities) {\n        const entity = this.htmlEntities[entityName];\n        val = val.replace(entity.regex, entity.val);\n      }\n    }\n    val = val.replace(this.ampEntity.regex, this.ampEntity.val);\n  }\n  return val;\n};\nfunction saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {\n  if (textData) {\n    //store previously collected data as textNode\n    if (isLeafNode === undefined) isLeafNode = currentNode.child.length === 0;\n    textData = this.parseTextData(textData, currentNode.tagname, jPath, false, currentNode[\":@\"] ? Object.keys(currentNode[\":@\"]).length !== 0 : false, isLeafNode);\n    if (textData !== undefined && textData !== \"\") currentNode.add(this.options.textNodeName, textData);\n    textData = \"\";\n  }\n  return textData;\n}\n\n//TODO: use jPath to simplify the logic\n/**\n * @param {Set} stopNodesExact\n * @param {Set} stopNodesWildcard\n * @param {string} jPath\n * @param {string} currentTagName\n */\nfunction isItStopNode(stopNodesExact, stopNodesWildcard, jPath, currentTagName) {\n  if (stopNodesWildcard && stopNodesWildcard.has(currentTagName)) return true;\n  if (stopNodesExact && stopNodesExact.has(jPath)) return true;\n  return false;\n}\n\n/**\n * Returns the tag Expression and where it is ending handling single-double quotes situation\n * @param {string} xmlData \n * @param {number} i starting index\n * @returns \n */\nfunction tagExpWithClosingIndex(xmlData, i, closingChar = \">\") {\n  let attrBoundary;\n  let tagExp = \"\";\n  for (let index = i; index < xmlData.length; index++) {\n    let ch = xmlData[index];\n    if (attrBoundary) {\n      if (ch === attrBoundary) attrBoundary = \"\"; //reset\n    } else if (ch === '\"' || ch === \"'\") {\n      attrBoundary = ch;\n    } else if (ch === closingChar[0]) {\n      if (closingChar[1]) {\n        if (xmlData[index + 1] === closingChar[1]) {\n          return {\n            data: tagExp,\n            index: index\n          };\n        }\n      } else {\n        return {\n          data: tagExp,\n          index: index\n        };\n      }\n    } else if (ch === '\\t') {\n      ch = \" \";\n    }\n    tagExp += ch;\n  }\n}\nfunction findClosingIndex(xmlData, str, i, errMsg) {\n  const closingIndex = xmlData.indexOf(str, i);\n  if (closingIndex === -1) {\n    throw new Error(errMsg);\n  } else {\n    return closingIndex + str.length - 1;\n  }\n}\nfunction readTagExp(xmlData, i, removeNSPrefix, closingChar = \">\") {\n  const result = tagExpWithClosingIndex(xmlData, i + 1, closingChar);\n  if (!result) return;\n  let tagExp = result.data;\n  const closeIndex = result.index;\n  const separatorIndex = tagExp.search(/\\s/);\n  let tagName = tagExp;\n  let attrExpPresent = true;\n  if (separatorIndex !== -1) {\n    //separate tag name and attributes expression\n    tagName = tagExp.substring(0, separatorIndex);\n    tagExp = tagExp.substring(separatorIndex + 1).trimStart();\n  }\n  const rawTagName = tagName;\n  if (removeNSPrefix) {\n    const colonIndex = tagName.indexOf(\":\");\n    if (colonIndex !== -1) {\n      tagName = tagName.substr(colonIndex + 1);\n      attrExpPresent = tagName !== result.data.substr(colonIndex + 1);\n    }\n  }\n  return {\n    tagName: tagName,\n    tagExp: tagExp,\n    closeIndex: closeIndex,\n    attrExpPresent: attrExpPresent,\n    rawTagName: rawTagName\n  };\n}\n/**\n * find paired tag for a stop node\n * @param {string} xmlData \n * @param {string} tagName \n * @param {number} i \n */\nfunction readStopNodeData(xmlData, tagName, i) {\n  const startIndex = i;\n  // Starting at 1 since we already have an open tag\n  let openTagCount = 1;\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] === \"<\") {\n      if (xmlData[i + 1] === \"/\") {\n        //close tag\n        const closeIndex = findClosingIndex(xmlData, \">\", i, `${tagName} is not closed`);\n        let closeTagName = xmlData.substring(i + 2, closeIndex).trim();\n        if (closeTagName === tagName) {\n          openTagCount--;\n          if (openTagCount === 0) {\n            return {\n              tagContent: xmlData.substring(startIndex, i),\n              i: closeIndex\n            };\n          }\n        }\n        i = closeIndex;\n      } else if (xmlData[i + 1] === '?') {\n        const closeIndex = findClosingIndex(xmlData, \"?>\", i + 1, \"StopNode is not closed.\");\n        i = closeIndex;\n      } else if (xmlData.substr(i + 1, 3) === '!--') {\n        const closeIndex = findClosingIndex(xmlData, \"-->\", i + 3, \"StopNode is not closed.\");\n        i = closeIndex;\n      } else if (xmlData.substr(i + 1, 2) === '![') {\n        const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"StopNode is not closed.\") - 2;\n        i = closeIndex;\n      } else {\n        const tagData = readTagExp(xmlData, i, '>');\n        if (tagData) {\n          const openTagName = tagData && tagData.tagName;\n          if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== \"/\") {\n            openTagCount++;\n          }\n          i = tagData.closeIndex;\n        }\n      }\n    }\n  } //end for loop\n}\nfunction parseValue(val, shouldParse, options) {\n  if (shouldParse && typeof val === 'string') {\n    //console.log(options)\n    const newval = val.trim();\n    if (newval === 'true') return true;else if (newval === 'false') return false;else return toNumber(val, options);\n  } else {\n    if (isExist(val)) {\n      return val;\n    } else {\n      return '';\n    }\n  }\n}","map":{"version":3,"names":["getAllMatches","isExist","xmlNode","DocTypeReader","toNumber","getIgnoreAttributesFn","OrderedObjParser","constructor","options","currentNode","tagsNodeStack","docTypeEntities","lastEntities","regex","val","ampEntity","htmlEntities","_","str","String","fromCodePoint","Number","parseInt","addExternalEntities","parseXml","parseTextData","resolveNameSpace","buildAttributesMap","isItStopNode","replaceEntitiesValue","readStopNodeData","saveTextToParentTag","addChild","ignoreAttributesFn","ignoreAttributes","stopNodes","length","stopNodesExact","Set","stopNodesWildcard","i","stopNodeExp","startsWith","add","substring","externalEntities","entKeys","Object","keys","ent","RegExp","tagName","jPath","dontTrim","hasAttributes","isLeafNode","escapeEntities","undefined","trimValues","trim","newval","tagValueProcessor","parseValue","parseTagValue","numberParseOptions","trimmedVal","tagname","removeNSPrefix","tags","split","prefix","charAt","attrsRegx","attrStr","matches","len","attrs","attrName","oldVal","aName","attributeNamePrefix","transformAttributeName","newVal","attributeValueProcessor","parseAttributeValue","allowBooleanAttributes","attributesGroupName","attrCollection","xmlData","replace","xmlObj","textData","docTypeReader","processEntities","ch","closeIndex","findClosingIndex","colonIndex","indexOf","substr","transformTagName","lastTagName","lastIndexOf","unpairedTags","Error","propIndex","pop","tagData","readTagExp","ignoreDeclaration","ignorePiTags","childNode","textNodeName","tagExp","attrExpPresent","endIndex","commentPropName","comment","result","readDocType","entities","cdataPropName","rawTagName","lastTag","startIndex","tagContent","push","child","captureMetaData","updateTag","entityName","entity","regx","currentTagName","has","tagExpWithClosingIndex","closingChar","attrBoundary","index","data","errMsg","closingIndex","separatorIndex","search","trimStart","openTagCount","closeTagName","openTagName","shouldParse"],"sources":["/Users/pascal/workspace/plan_de_charge/front/node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js"],"sourcesContent":["'use strict';\n///@ts-check\n\nimport {getAllMatches, isExist} from '../util.js';\nimport xmlNode from './xmlNode.js';\nimport DocTypeReader from './DocTypeReader.js';\nimport toNumber from \"strnum\";\nimport getIgnoreAttributesFn from \"../ignoreAttributes.js\";\n\n// const regx =\n//   '<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\\\/)(NAME)\\\\s*>))([^<]*)'\n//   .replace(/NAME/g, util.nameRegexp);\n\n//const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\n\nexport default class OrderedObjParser{\n  constructor(options){\n    this.options = options;\n    this.currentNode = null;\n    this.tagsNodeStack = [];\n    this.docTypeEntities = {};\n    this.lastEntities = {\n      \"apos\" : { regex: /&(apos|#39|#x27);/g, val : \"'\"},\n      \"gt\" : { regex: /&(gt|#62|#x3E);/g, val : \">\"},\n      \"lt\" : { regex: /&(lt|#60|#x3C);/g, val : \"<\"},\n      \"quot\" : { regex: /&(quot|#34|#x22);/g, val : \"\\\"\"},\n    };\n    this.ampEntity = { regex: /&(amp|#38|#x26);/g, val : \"&\"};\n    this.htmlEntities = {\n      \"space\": { regex: /&(nbsp|#160);/g, val: \" \" },\n      // \"lt\" : { regex: /&(lt|#60);/g, val: \"<\" },\n      // \"gt\" : { regex: /&(gt|#62);/g, val: \">\" },\n      // \"amp\" : { regex: /&(amp|#38);/g, val: \"&\" },\n      // \"quot\" : { regex: /&(quot|#34);/g, val: \"\\\"\" },\n      // \"apos\" : { regex: /&(apos|#39);/g, val: \"'\" },\n      \"cent\" : { regex: /&(cent|#162);/g, val: \"¢\" },\n      \"pound\" : { regex: /&(pound|#163);/g, val: \"£\" },\n      \"yen\" : { regex: /&(yen|#165);/g, val: \"¥\" },\n      \"euro\" : { regex: /&(euro|#8364);/g, val: \"€\" },\n      \"copyright\" : { regex: /&(copy|#169);/g, val: \"©\" },\n      \"reg\" : { regex: /&(reg|#174);/g, val: \"®\" },\n      \"inr\" : { regex: /&(inr|#8377);/g, val: \"₹\" },\n      \"num_dec\": { regex: /&#([0-9]{1,7});/g, val : (_, str) => String.fromCodePoint(Number.parseInt(str, 10)) },\n      \"num_hex\": { regex: /&#x([0-9a-fA-F]{1,6});/g, val : (_, str) => String.fromCodePoint(Number.parseInt(str, 16)) },\n    };\n    this.addExternalEntities = addExternalEntities;\n    this.parseXml = parseXml;\n    this.parseTextData = parseTextData;\n    this.resolveNameSpace = resolveNameSpace;\n    this.buildAttributesMap = buildAttributesMap;\n    this.isItStopNode = isItStopNode;\n    this.replaceEntitiesValue = replaceEntitiesValue;\n    this.readStopNodeData = readStopNodeData;\n    this.saveTextToParentTag = saveTextToParentTag;\n    this.addChild = addChild;\n    this.ignoreAttributesFn = getIgnoreAttributesFn(this.options.ignoreAttributes)\n\n    if(this.options.stopNodes && this.options.stopNodes.length > 0){\n      this.stopNodesExact = new Set();\n      this.stopNodesWildcard = new Set();\n      for(let i = 0; i < this.options.stopNodes.length; i++){\n        const stopNodeExp = this.options.stopNodes[i];\n        if(typeof stopNodeExp !== 'string') continue;\n        if(stopNodeExp.startsWith(\"*.\")){\n          this.stopNodesWildcard.add(stopNodeExp.substring(2));\n        }else{\n          this.stopNodesExact.add(stopNodeExp);\n        }\n      }\n    }\n  }\n\n}\n\nfunction addExternalEntities(externalEntities){\n  const entKeys = Object.keys(externalEntities);\n  for (let i = 0; i < entKeys.length; i++) {\n    const ent = entKeys[i];\n    this.lastEntities[ent] = {\n       regex: new RegExp(\"&\"+ent+\";\",\"g\"),\n       val : externalEntities[ent]\n    }\n  }\n}\n\n/**\n * @param {string} val\n * @param {string} tagName\n * @param {string} jPath\n * @param {boolean} dontTrim\n * @param {boolean} hasAttributes\n * @param {boolean} isLeafNode\n * @param {boolean} escapeEntities\n */\nfunction parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {\n  if (val !== undefined) {\n    if (this.options.trimValues && !dontTrim) {\n      val = val.trim();\n    }\n    if(val.length > 0){\n      if(!escapeEntities) val = this.replaceEntitiesValue(val);\n      \n      const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);\n      if(newval === null || newval === undefined){\n        //don't parse\n        return val;\n      }else if(typeof newval !== typeof val || newval !== val){\n        //overwrite\n        return newval;\n      }else if(this.options.trimValues){\n        return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n      }else{\n        const trimmedVal = val.trim();\n        if(trimmedVal === val){\n          return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n        }else{\n          return val;\n        }\n      }\n    }\n  }\n}\n\nfunction resolveNameSpace(tagname) {\n  if (this.options.removeNSPrefix) {\n    const tags = tagname.split(':');\n    const prefix = tagname.charAt(0) === '/' ? '/' : '';\n    if (tags[0] === 'xmlns') {\n      return '';\n    }\n    if (tags.length === 2) {\n      tagname = prefix + tags[1];\n    }\n  }\n  return tagname;\n}\n\n//TODO: change regex to capture NS\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\nconst attrsRegx = new RegExp('([^\\\\s=]+)\\\\s*(=\\\\s*([\\'\"])([\\\\s\\\\S]*?)\\\\3)?', 'gm');\n\nfunction buildAttributesMap(attrStr, jPath, tagName) {\n  if (this.options.ignoreAttributes !== true && typeof attrStr === 'string') {\n    // attrStr = attrStr.replace(/\\r?\\n/g, ' ');\n    //attrStr = attrStr || attrStr.trim();\n\n    const matches = getAllMatches(attrStr, attrsRegx);\n    const len = matches.length; //don't make it inline\n    const attrs = {};\n    for (let i = 0; i < len; i++) {\n      const attrName = this.resolveNameSpace(matches[i][1]);\n      if (this.ignoreAttributesFn(attrName, jPath)) {\n        continue\n      }\n      let oldVal = matches[i][4];\n      let aName = this.options.attributeNamePrefix + attrName;\n      if (attrName.length) {\n        if (this.options.transformAttributeName) {\n          aName = this.options.transformAttributeName(aName);\n        }\n        if(aName === \"__proto__\") aName  = \"#__proto__\";\n        if (oldVal !== undefined) {\n          if (this.options.trimValues) {\n            oldVal = oldVal.trim();\n          }\n          oldVal = this.replaceEntitiesValue(oldVal);\n          const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);\n          if(newVal === null || newVal === undefined){\n            //don't parse\n            attrs[aName] = oldVal;\n          }else if(typeof newVal !== typeof oldVal || newVal !== oldVal){\n            //overwrite\n            attrs[aName] = newVal;\n          }else{\n            //parse\n            attrs[aName] = parseValue(\n              oldVal,\n              this.options.parseAttributeValue,\n              this.options.numberParseOptions\n            );\n          }\n        } else if (this.options.allowBooleanAttributes) {\n          attrs[aName] = true;\n        }\n      }\n    }\n    if (!Object.keys(attrs).length) {\n      return;\n    }\n    if (this.options.attributesGroupName) {\n      const attrCollection = {};\n      attrCollection[this.options.attributesGroupName] = attrs;\n      return attrCollection;\n    }\n    return attrs\n  }\n}\n\nconst parseXml = function(xmlData) {\n  xmlData = xmlData.replace(/\\r\\n?/g, \"\\n\"); //TODO: remove this line\n  const xmlObj = new xmlNode('!xml');\n  let currentNode = xmlObj;\n  let textData = \"\";\n  let jPath = \"\";\n  const docTypeReader = new DocTypeReader(this.options.processEntities);\n  for(let i=0; i< xmlData.length; i++){//for each char in XML data\n    const ch = xmlData[i];\n    if(ch === '<'){\n      // const nextIndex = i+1;\n      // const _2ndChar = xmlData[nextIndex];\n      if( xmlData[i+1] === '/') {//Closing Tag\n        const closeIndex = findClosingIndex(xmlData, \">\", i, \"Closing Tag is not closed.\")\n        let tagName = xmlData.substring(i+2,closeIndex).trim();\n\n        if(this.options.removeNSPrefix){\n          const colonIndex = tagName.indexOf(\":\");\n          if(colonIndex !== -1){\n            tagName = tagName.substr(colonIndex+1);\n          }\n        }\n\n        if(this.options.transformTagName) {\n          tagName = this.options.transformTagName(tagName);\n        }\n\n        if(currentNode){\n          textData = this.saveTextToParentTag(textData, currentNode, jPath);\n        }\n\n        //check if last tag of nested tag was unpaired tag\n        const lastTagName = jPath.substring(jPath.lastIndexOf(\".\")+1);\n        if(tagName && this.options.unpairedTags.indexOf(tagName) !== -1 ){\n          throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);\n        }\n        let propIndex = 0\n        if(lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1 ){\n          propIndex = jPath.lastIndexOf('.', jPath.lastIndexOf('.')-1)\n          this.tagsNodeStack.pop();\n        }else{\n          propIndex = jPath.lastIndexOf(\".\");\n        }\n        jPath = jPath.substring(0, propIndex);\n\n        currentNode = this.tagsNodeStack.pop();//avoid recursion, set the parent tag scope\n        textData = \"\";\n        i = closeIndex;\n      } else if( xmlData[i+1] === '?') {\n\n        let tagData = readTagExp(xmlData,i, false, \"?>\");\n        if(!tagData) throw new Error(\"Pi Tag is not closed.\");\n\n        textData = this.saveTextToParentTag(textData, currentNode, jPath);\n        if( (this.options.ignoreDeclaration && tagData.tagName === \"?xml\") || this.options.ignorePiTags){\n\n        }else{\n  \n          const childNode = new xmlNode(tagData.tagName);\n          childNode.add(this.options.textNodeName, \"\");\n          \n          if(tagData.tagName !== tagData.tagExp && tagData.attrExpPresent){\n            childNode[\":@\"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);\n          }\n          this.addChild(currentNode, childNode, jPath, i);\n        }\n\n\n        i = tagData.closeIndex + 1;\n      } else if(xmlData.substr(i + 1, 3) === '!--') {\n        const endIndex = findClosingIndex(xmlData, \"-->\", i+4, \"Comment is not closed.\")\n        if(this.options.commentPropName){\n          const comment = xmlData.substring(i + 4, endIndex - 2);\n\n          textData = this.saveTextToParentTag(textData, currentNode, jPath);\n\n          currentNode.add(this.options.commentPropName, [ { [this.options.textNodeName] : comment } ]);\n        }\n        i = endIndex;\n      } else if( xmlData.substr(i + 1, 2) === '!D') {\n        const result = docTypeReader.readDocType(xmlData, i);\n        this.docTypeEntities = result.entities;\n        i = result.i;\n      }else if(xmlData.substr(i + 1, 2) === '![') {\n        const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"CDATA is not closed.\") - 2;\n        const tagExp = xmlData.substring(i + 9,closeIndex);\n\n        textData = this.saveTextToParentTag(textData, currentNode, jPath);\n\n        let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);\n        if(val == undefined) val = \"\";\n\n        //cdata should be set even if it is 0 length string\n        if(this.options.cdataPropName){\n          currentNode.add(this.options.cdataPropName, [ { [this.options.textNodeName] : tagExp } ]);\n        }else{\n          currentNode.add(this.options.textNodeName, val);\n        }\n        \n        i = closeIndex + 2;\n      }else {//Opening tag\n        let result = readTagExp(xmlData,i, this.options.removeNSPrefix);\n        let tagName= result.tagName;\n        const rawTagName = result.rawTagName;\n        let tagExp = result.tagExp;\n        let attrExpPresent = result.attrExpPresent;\n        let closeIndex = result.closeIndex;\n\n        if (this.options.transformTagName) {\n          tagName = this.options.transformTagName(tagName);\n        }\n        \n        //save text as child node\n        if (currentNode && textData) {\n          if(currentNode.tagname !== '!xml'){\n            //when nested tag is found\n            textData = this.saveTextToParentTag(textData, currentNode, jPath, false);\n          }\n        }\n\n        //check if last tag was unpaired tag\n        const lastTag = currentNode;\n        if(lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1 ){\n          currentNode = this.tagsNodeStack.pop();\n          jPath = jPath.substring(0, jPath.lastIndexOf(\".\"));\n        }\n        if(tagName !== xmlObj.tagname){\n          jPath += jPath ? \".\" + tagName : tagName;\n        }\n        const startIndex = i;\n        if (this.isItStopNode(this.stopNodesExact, this.stopNodesWildcard, jPath, tagName)) {\n          let tagContent = \"\";\n          //self-closing tag\n          if(tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1){\n            if(tagName[tagName.length - 1] === \"/\"){ //remove trailing '/'\n              tagName = tagName.substr(0, tagName.length - 1);\n              jPath = jPath.substr(0, jPath.length - 1);\n              tagExp = tagName;\n            }else{\n              tagExp = tagExp.substr(0, tagExp.length - 1);\n            }\n            i = result.closeIndex;\n          }\n          //unpaired tag\n          else if(this.options.unpairedTags.indexOf(tagName) !== -1){\n            \n            i = result.closeIndex;\n          }\n          //normal tag\n          else{\n            //read until closing tag is found\n            const result = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);\n            if(!result) throw new Error(`Unexpected end of ${rawTagName}`);\n            i = result.i;\n            tagContent = result.tagContent;\n          }\n\n          const childNode = new xmlNode(tagName);\n\n          if(tagName !== tagExp && attrExpPresent){\n            childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n          }\n          if(tagContent) {\n            tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);\n          }\n          \n          jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n          childNode.add(this.options.textNodeName, tagContent);\n          \n          this.addChild(currentNode, childNode, jPath, startIndex);\n        }else{\n  //selfClosing tag\n          if(tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1){\n            if(tagName[tagName.length - 1] === \"/\"){ //remove trailing '/'\n              tagName = tagName.substr(0, tagName.length - 1);\n              jPath = jPath.substr(0, jPath.length - 1);\n              tagExp = tagName;\n            }else{\n              tagExp = tagExp.substr(0, tagExp.length - 1);\n            }\n            \n            if(this.options.transformTagName) {\n              tagName = this.options.transformTagName(tagName);\n            }\n\n            const childNode = new xmlNode(tagName);\n            if(tagName !== tagExp && attrExpPresent){\n              childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n            }\n            this.addChild(currentNode, childNode, jPath, startIndex);\n            jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n          }\n    //opening tag\n          else{\n            const childNode = new xmlNode( tagName);\n            this.tagsNodeStack.push(currentNode);\n            \n            if(tagName !== tagExp && attrExpPresent){\n              childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n            }\n            this.addChild(currentNode, childNode, jPath, startIndex);\n            currentNode = childNode;\n          }\n          textData = \"\";\n          i = closeIndex;\n        }\n      }\n    }else{\n      textData += xmlData[i];\n    }\n  }\n  return xmlObj.child;\n}\n\nfunction addChild(currentNode, childNode, jPath, startIndex){\n  // unset startIndex if not requested\n  if (!this.options.captureMetaData) startIndex = undefined;\n  const result = this.options.updateTag(childNode.tagname, jPath, childNode[\":@\"])\n  if(result === false){\n  } else if(typeof result === \"string\"){\n    childNode.tagname = result\n    currentNode.addChild(childNode, startIndex);\n  }else{\n    currentNode.addChild(childNode, startIndex);\n  }\n}\n\nconst replaceEntitiesValue = function(val){\n\n  if(this.options.processEntities){\n    for(let entityName in this.docTypeEntities){\n      const entity = this.docTypeEntities[entityName];\n      val = val.replace( entity.regx, entity.val);\n    }\n    for(let entityName in this.lastEntities){\n      const entity = this.lastEntities[entityName];\n      val = val.replace( entity.regex, entity.val);\n    }\n    if(this.options.htmlEntities){\n      for(let entityName in this.htmlEntities){\n        const entity = this.htmlEntities[entityName];\n        val = val.replace( entity.regex, entity.val);\n      }\n    }\n    val = val.replace( this.ampEntity.regex, this.ampEntity.val);\n  }\n  return val;\n}\nfunction saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {\n  if (textData) { //store previously collected data as textNode\n    if(isLeafNode === undefined) isLeafNode = currentNode.child.length === 0\n    \n    textData = this.parseTextData(textData,\n      currentNode.tagname,\n      jPath,\n      false,\n      currentNode[\":@\"] ? Object.keys(currentNode[\":@\"]).length !== 0 : false,\n      isLeafNode);\n\n    if (textData !== undefined && textData !== \"\")\n      currentNode.add(this.options.textNodeName, textData);\n    textData = \"\";\n  }\n  return textData;\n}\n\n//TODO: use jPath to simplify the logic\n/**\n * @param {Set} stopNodesExact\n * @param {Set} stopNodesWildcard\n * @param {string} jPath\n * @param {string} currentTagName\n */\nfunction isItStopNode(stopNodesExact, stopNodesWildcard, jPath, currentTagName){\n  if(stopNodesWildcard && stopNodesWildcard.has(currentTagName)) return true;\n  if(stopNodesExact && stopNodesExact.has(jPath)) return true;\n  return false;\n}\n\n/**\n * Returns the tag Expression and where it is ending handling single-double quotes situation\n * @param {string} xmlData \n * @param {number} i starting index\n * @returns \n */\nfunction tagExpWithClosingIndex(xmlData, i, closingChar = \">\"){\n  let attrBoundary;\n  let tagExp = \"\";\n  for (let index = i; index < xmlData.length; index++) {\n    let ch = xmlData[index];\n    if (attrBoundary) {\n        if (ch === attrBoundary) attrBoundary = \"\";//reset\n    } else if (ch === '\"' || ch === \"'\") {\n        attrBoundary = ch;\n    } else if (ch === closingChar[0]) {\n      if(closingChar[1]){\n        if(xmlData[index + 1] === closingChar[1]){\n          return {\n            data: tagExp,\n            index: index\n          }\n        }\n      }else{\n        return {\n          data: tagExp,\n          index: index\n        }\n      }\n    } else if (ch === '\\t') {\n      ch = \" \"\n    }\n    tagExp += ch;\n  }\n}\n\nfunction findClosingIndex(xmlData, str, i, errMsg){\n  const closingIndex = xmlData.indexOf(str, i);\n  if(closingIndex === -1){\n    throw new Error(errMsg)\n  }else{\n    return closingIndex + str.length - 1;\n  }\n}\n\nfunction readTagExp(xmlData,i, removeNSPrefix, closingChar = \">\"){\n  const result = tagExpWithClosingIndex(xmlData, i+1, closingChar);\n  if(!result) return;\n  let tagExp = result.data;\n  const closeIndex = result.index;\n  const separatorIndex = tagExp.search(/\\s/);\n  let tagName = tagExp;\n  let attrExpPresent = true;\n  if(separatorIndex !== -1){//separate tag name and attributes expression\n    tagName = tagExp.substring(0, separatorIndex);\n    tagExp = tagExp.substring(separatorIndex + 1).trimStart();\n  }\n\n  const rawTagName = tagName;\n  if(removeNSPrefix){\n    const colonIndex = tagName.indexOf(\":\");\n    if(colonIndex !== -1){\n      tagName = tagName.substr(colonIndex+1);\n      attrExpPresent = tagName !== result.data.substr(colonIndex + 1);\n    }\n  }\n\n  return {\n    tagName: tagName,\n    tagExp: tagExp,\n    closeIndex: closeIndex,\n    attrExpPresent: attrExpPresent,\n    rawTagName: rawTagName,\n  }\n}\n/**\n * find paired tag for a stop node\n * @param {string} xmlData \n * @param {string} tagName \n * @param {number} i \n */\nfunction readStopNodeData(xmlData, tagName, i){\n  const startIndex = i;\n  // Starting at 1 since we already have an open tag\n  let openTagCount = 1;\n\n  for (; i < xmlData.length; i++) {\n    if( xmlData[i] === \"<\"){ \n      if (xmlData[i+1] === \"/\") {//close tag\n          const closeIndex = findClosingIndex(xmlData, \">\", i, `${tagName} is not closed`);\n          let closeTagName = xmlData.substring(i+2,closeIndex).trim();\n          if(closeTagName === tagName){\n            openTagCount--;\n            if (openTagCount === 0) {\n              return {\n                tagContent: xmlData.substring(startIndex, i),\n                i : closeIndex\n              }\n            }\n          }\n          i=closeIndex;\n        } else if(xmlData[i+1] === '?') { \n          const closeIndex = findClosingIndex(xmlData, \"?>\", i+1, \"StopNode is not closed.\")\n          i=closeIndex;\n        } else if(xmlData.substr(i + 1, 3) === '!--') { \n          const closeIndex = findClosingIndex(xmlData, \"-->\", i+3, \"StopNode is not closed.\")\n          i=closeIndex;\n        } else if(xmlData.substr(i + 1, 2) === '![') { \n          const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"StopNode is not closed.\") - 2;\n          i=closeIndex;\n        } else {\n          const tagData = readTagExp(xmlData, i, '>')\n\n          if (tagData) {\n            const openTagName = tagData && tagData.tagName;\n            if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length-1] !== \"/\") {\n              openTagCount++;\n            }\n            i=tagData.closeIndex;\n          }\n        }\n      }\n  }//end for loop\n}\n\nfunction parseValue(val, shouldParse, options) {\n  if (shouldParse && typeof val === 'string') {\n    //console.log(options)\n    const newval = val.trim();\n    if(newval === 'true' ) return true;\n    else if(newval === 'false' ) return false;\n    else return toNumber(val, options);\n  } else {\n    if (isExist(val)) {\n      return val;\n    } else {\n      return '';\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}