{"ast":null,"code":"import { isName } from '../util.js';\nexport default class DocTypeReader {\n  constructor(processEntities) {\n    this.suppressValidationErr = !processEntities;\n  }\n  readDocType(xmlData, i) {\n    const entities = {};\n    if (xmlData[i + 3] === 'O' && xmlData[i + 4] === 'C' && xmlData[i + 5] === 'T' && xmlData[i + 6] === 'Y' && xmlData[i + 7] === 'P' && xmlData[i + 8] === 'E') {\n      i = i + 9;\n      let angleBracketsCount = 1;\n      let hasBody = false,\n        comment = false;\n      let exp = \"\";\n      for (; i < xmlData.length; i++) {\n        if (xmlData[i] === '<' && !comment) {\n          //Determine the tag type\n          if (hasBody && hasSeq(xmlData, \"!ENTITY\", i)) {\n            i += 7;\n            let entityName, val;\n            [entityName, val, i] = this.readEntityExp(xmlData, i + 1, this.suppressValidationErr);\n            if (val.indexOf(\"&\") === -1)\n              //Parameter entities are not supported\n              entities[entityName] = {\n                regx: RegExp(`&${entityName};`, \"g\"),\n                val: val\n              };\n          } else if (hasBody && hasSeq(xmlData, \"!ELEMENT\", i)) {\n            i += 8; //Not supported\n            const {\n              index\n            } = this.readElementExp(xmlData, i + 1);\n            i = index;\n          } else if (hasBody && hasSeq(xmlData, \"!ATTLIST\", i)) {\n            i += 8; //Not supported\n            // const {index} = this.readAttlistExp(xmlData,i+1);\n            // i = index;\n          } else if (hasBody && hasSeq(xmlData, \"!NOTATION\", i)) {\n            i += 9; //Not supported\n            const {\n              index\n            } = this.readNotationExp(xmlData, i + 1, this.suppressValidationErr);\n            i = index;\n          } else if (hasSeq(xmlData, \"!--\", i)) comment = true;else throw new Error(`Invalid DOCTYPE`);\n          angleBracketsCount++;\n          exp = \"\";\n        } else if (xmlData[i] === '>') {\n          //Read tag content\n          if (comment) {\n            if (xmlData[i - 1] === \"-\" && xmlData[i - 2] === \"-\") {\n              comment = false;\n              angleBracketsCount--;\n            }\n          } else {\n            angleBracketsCount--;\n          }\n          if (angleBracketsCount === 0) {\n            break;\n          }\n        } else if (xmlData[i] === '[') {\n          hasBody = true;\n        } else {\n          exp += xmlData[i];\n        }\n      }\n      if (angleBracketsCount !== 0) {\n        throw new Error(`Unclosed DOCTYPE`);\n      }\n    } else {\n      throw new Error(`Invalid Tag instead of DOCTYPE`);\n    }\n    return {\n      entities,\n      i\n    };\n  }\n  readEntityExp(xmlData, i) {\n    //External entities are not supported\n    //    <!ENTITY ext SYSTEM \"http://normal-website.com\" >\n\n    //Parameter entities are not supported\n    //    <!ENTITY entityname \"&anotherElement;\">\n\n    //Internal entities are supported\n    //    <!ENTITY entityname \"replacement text\">\n\n    // Skip leading whitespace after <!ENTITY\n    i = skipWhitespace(xmlData, i);\n\n    // Read entity name\n    let entityName = \"\";\n    while (i < xmlData.length && !/\\s/.test(xmlData[i]) && xmlData[i] !== '\"' && xmlData[i] !== \"'\") {\n      entityName += xmlData[i];\n      i++;\n    }\n    validateEntityName(entityName);\n\n    // Skip whitespace after entity name\n    i = skipWhitespace(xmlData, i);\n\n    // Check for unsupported constructs (external entities or parameter entities)\n    if (!this.suppressValidationErr) {\n      if (xmlData.substring(i, i + 6).toUpperCase() === \"SYSTEM\") {\n        throw new Error(\"External entities are not supported\");\n      } else if (xmlData[i] === \"%\") {\n        throw new Error(\"Parameter entities are not supported\");\n      }\n    }\n\n    // Read entity value (internal entity)\n    let entityValue = \"\";\n    [i, entityValue] = this.readIdentifierVal(xmlData, i, \"entity\");\n    i--;\n    return [entityName, entityValue, i];\n  }\n  readNotationExp(xmlData, i) {\n    // Skip leading whitespace after <!NOTATION\n    i = skipWhitespace(xmlData, i);\n\n    // Read notation name\n    let notationName = \"\";\n    while (i < xmlData.length && !/\\s/.test(xmlData[i])) {\n      notationName += xmlData[i];\n      i++;\n    }\n    !this.suppressValidationErr && validateEntityName(notationName);\n\n    // Skip whitespace after notation name\n    i = skipWhitespace(xmlData, i);\n\n    // Check identifier type (SYSTEM or PUBLIC)\n    const identifierType = xmlData.substring(i, i + 6).toUpperCase();\n    if (!this.suppressValidationErr && identifierType !== \"SYSTEM\" && identifierType !== \"PUBLIC\") {\n      throw new Error(`Expected SYSTEM or PUBLIC, found \"${identifierType}\"`);\n    }\n    i += identifierType.length;\n\n    // Skip whitespace after identifier type\n    i = skipWhitespace(xmlData, i);\n\n    // Read public identifier (if PUBLIC)\n    let publicIdentifier = null;\n    let systemIdentifier = null;\n    if (identifierType === \"PUBLIC\") {\n      [i, publicIdentifier] = this.readIdentifierVal(xmlData, i, \"publicIdentifier\");\n\n      // Skip whitespace after public identifier\n      i = skipWhitespace(xmlData, i);\n\n      // Optionally read system identifier\n      if (xmlData[i] === '\"' || xmlData[i] === \"'\") {\n        [i, systemIdentifier] = this.readIdentifierVal(xmlData, i, \"systemIdentifier\");\n      }\n    } else if (identifierType === \"SYSTEM\") {\n      // Read system identifier (mandatory for SYSTEM)\n      [i, systemIdentifier] = this.readIdentifierVal(xmlData, i, \"systemIdentifier\");\n      if (!this.suppressValidationErr && !systemIdentifier) {\n        throw new Error(\"Missing mandatory system identifier for SYSTEM notation\");\n      }\n    }\n    return {\n      notationName,\n      publicIdentifier,\n      systemIdentifier,\n      index: --i\n    };\n  }\n  readIdentifierVal(xmlData, i, type) {\n    let identifierVal = \"\";\n    const startChar = xmlData[i];\n    if (startChar !== '\"' && startChar !== \"'\") {\n      throw new Error(`Expected quoted string, found \"${startChar}\"`);\n    }\n    i++;\n    while (i < xmlData.length && xmlData[i] !== startChar) {\n      identifierVal += xmlData[i];\n      i++;\n    }\n    if (xmlData[i] !== startChar) {\n      throw new Error(`Unterminated ${type} value`);\n    }\n    i++;\n    return [i, identifierVal];\n  }\n  readElementExp(xmlData, i) {\n    // <!ELEMENT br EMPTY>\n    // <!ELEMENT div ANY>\n    // <!ELEMENT title (#PCDATA)>\n    // <!ELEMENT book (title, author+)>\n    // <!ELEMENT name (content-model)>\n\n    // Skip leading whitespace after <!ELEMENT\n    i = skipWhitespace(xmlData, i);\n\n    // Read element name\n    let elementName = \"\";\n    while (i < xmlData.length && !/\\s/.test(xmlData[i])) {\n      elementName += xmlData[i];\n      i++;\n    }\n\n    // Validate element name\n    if (!this.suppressValidationErr && !isName(elementName)) {\n      throw new Error(`Invalid element name: \"${elementName}\"`);\n    }\n\n    // Skip whitespace after element name\n    i = skipWhitespace(xmlData, i);\n    let contentModel = \"\";\n    // Expect '(' to start content model\n    if (xmlData[i] === \"E\" && hasSeq(xmlData, \"MPTY\", i)) i += 4;else if (xmlData[i] === \"A\" && hasSeq(xmlData, \"NY\", i)) i += 2;else if (xmlData[i] === \"(\") {\n      i++; // Move past '('\n\n      // Read content model\n      while (i < xmlData.length && xmlData[i] !== \")\") {\n        contentModel += xmlData[i];\n        i++;\n      }\n      if (xmlData[i] !== \")\") {\n        throw new Error(\"Unterminated content model\");\n      }\n    } else if (!this.suppressValidationErr) {\n      throw new Error(`Invalid Element Expression, found \"${xmlData[i]}\"`);\n    }\n    return {\n      elementName,\n      contentModel: contentModel.trim(),\n      index: i\n    };\n  }\n  readAttlistExp(xmlData, i) {\n    // Skip leading whitespace after <!ATTLIST\n    i = skipWhitespace(xmlData, i);\n\n    // Read element name\n    let elementName = \"\";\n    while (i < xmlData.length && !/\\s/.test(xmlData[i])) {\n      elementName += xmlData[i];\n      i++;\n    }\n\n    // Validate element name\n    validateEntityName(elementName);\n\n    // Skip whitespace after element name\n    i = skipWhitespace(xmlData, i);\n\n    // Read attribute name\n    let attributeName = \"\";\n    while (i < xmlData.length && !/\\s/.test(xmlData[i])) {\n      attributeName += xmlData[i];\n      i++;\n    }\n\n    // Validate attribute name\n    if (!validateEntityName(attributeName)) {\n      throw new Error(`Invalid attribute name: \"${attributeName}\"`);\n    }\n\n    // Skip whitespace after attribute name\n    i = skipWhitespace(xmlData, i);\n\n    // Read attribute type\n    let attributeType = \"\";\n    if (xmlData.substring(i, i + 8).toUpperCase() === \"NOTATION\") {\n      attributeType = \"NOTATION\";\n      i += 8; // Move past \"NOTATION\"\n\n      // Skip whitespace after \"NOTATION\"\n      i = skipWhitespace(xmlData, i);\n\n      // Expect '(' to start the list of notations\n      if (xmlData[i] !== \"(\") {\n        throw new Error(`Expected '(', found \"${xmlData[i]}\"`);\n      }\n      i++; // Move past '('\n\n      // Read the list of allowed notations\n      let allowedNotations = [];\n      while (i < xmlData.length && xmlData[i] !== \")\") {\n        let notation = \"\";\n        while (i < xmlData.length && xmlData[i] !== \"|\" && xmlData[i] !== \")\") {\n          notation += xmlData[i];\n          i++;\n        }\n\n        // Validate notation name\n        notation = notation.trim();\n        if (!validateEntityName(notation)) {\n          throw new Error(`Invalid notation name: \"${notation}\"`);\n        }\n        allowedNotations.push(notation);\n\n        // Skip '|' separator or exit loop\n        if (xmlData[i] === \"|\") {\n          i++; // Move past '|'\n          i = skipWhitespace(xmlData, i); // Skip optional whitespace after '|'\n        }\n      }\n      if (xmlData[i] !== \")\") {\n        throw new Error(\"Unterminated list of notations\");\n      }\n      i++; // Move past ')'\n\n      // Store the allowed notations as part of the attribute type\n      attributeType += \" (\" + allowedNotations.join(\"|\") + \")\";\n    } else {\n      // Handle simple types (e.g., CDATA, ID, IDREF, etc.)\n      while (i < xmlData.length && !/\\s/.test(xmlData[i])) {\n        attributeType += xmlData[i];\n        i++;\n      }\n\n      // Validate simple attribute type\n      const validTypes = [\"CDATA\", \"ID\", \"IDREF\", \"IDREFS\", \"ENTITY\", \"ENTITIES\", \"NMTOKEN\", \"NMTOKENS\"];\n      if (!this.suppressValidationErr && !validTypes.includes(attributeType.toUpperCase())) {\n        throw new Error(`Invalid attribute type: \"${attributeType}\"`);\n      }\n    }\n\n    // Skip whitespace after attribute type\n    i = skipWhitespace(xmlData, i);\n\n    // Read default value\n    let defaultValue = \"\";\n    if (xmlData.substring(i, i + 8).toUpperCase() === \"#REQUIRED\") {\n      defaultValue = \"#REQUIRED\";\n      i += 8;\n    } else if (xmlData.substring(i, i + 7).toUpperCase() === \"#IMPLIED\") {\n      defaultValue = \"#IMPLIED\";\n      i += 7;\n    } else {\n      [i, defaultValue] = this.readIdentifierVal(xmlData, i, \"ATTLIST\");\n    }\n    return {\n      elementName,\n      attributeName,\n      attributeType,\n      defaultValue,\n      index: i\n    };\n  }\n}\nconst skipWhitespace = (data, index) => {\n  while (index < data.length && /\\s/.test(data[index])) {\n    index++;\n  }\n  return index;\n};\nfunction hasSeq(data, seq, i) {\n  for (let j = 0; j < seq.length; j++) {\n    if (seq[j] !== data[i + j + 1]) return false;\n  }\n  return true;\n}\nfunction validateEntityName(name) {\n  if (isName(name)) return name;else throw new Error(`Invalid entity name ${name}`);\n}","map":{"version":3,"names":["isName","DocTypeReader","constructor","processEntities","suppressValidationErr","readDocType","xmlData","i","entities","angleBracketsCount","hasBody","comment","exp","length","hasSeq","entityName","val","readEntityExp","indexOf","regx","RegExp","index","readElementExp","readNotationExp","Error","skipWhitespace","test","validateEntityName","substring","toUpperCase","entityValue","readIdentifierVal","notationName","identifierType","publicIdentifier","systemIdentifier","type","identifierVal","startChar","elementName","contentModel","trim","readAttlistExp","attributeName","attributeType","allowedNotations","notation","push","join","validTypes","includes","defaultValue","data","seq","j","name"],"sources":["/Users/pascal/workspace/plan_de_charge/front/node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js"],"sourcesContent":["import {isName} from '../util.js';\n\nexport default class DocTypeReader{\n    constructor(processEntities){\n        this.suppressValidationErr = !processEntities;\n    }\n    \n    readDocType(xmlData, i){\n    \n        const entities = {};\n        if( xmlData[i + 3] === 'O' &&\n            xmlData[i + 4] === 'C' &&\n            xmlData[i + 5] === 'T' &&\n            xmlData[i + 6] === 'Y' &&\n            xmlData[i + 7] === 'P' &&\n            xmlData[i + 8] === 'E')\n        {    \n            i = i+9;\n            let angleBracketsCount = 1;\n            let hasBody = false, comment = false;\n            let exp = \"\";\n            for(;i<xmlData.length;i++){\n                if (xmlData[i] === '<' && !comment) { //Determine the tag type\n                    if( hasBody && hasSeq(xmlData, \"!ENTITY\",i)){\n                        i += 7; \n                        let entityName, val;\n                        [entityName, val,i] = this.readEntityExp(xmlData,i+1,this.suppressValidationErr);\n                        if(val.indexOf(\"&\") === -1) //Parameter entities are not supported\n                            entities[ entityName ] = {\n                                regx : RegExp( `&${entityName};`,\"g\"),\n                                val: val\n                            };\n                    }\n                    else if( hasBody && hasSeq(xmlData, \"!ELEMENT\",i))  {\n                        i += 8;//Not supported\n                        const {index} = this.readElementExp(xmlData,i+1);\n                        i = index;\n                    }else if( hasBody && hasSeq(xmlData, \"!ATTLIST\",i)){\n                        i += 8;//Not supported\n                        // const {index} = this.readAttlistExp(xmlData,i+1);\n                        // i = index;\n                    }else if( hasBody && hasSeq(xmlData, \"!NOTATION\",i)) {\n                        i += 9;//Not supported\n                        const {index} = this.readNotationExp(xmlData,i+1,this.suppressValidationErr);\n                        i = index;\n                    }else if( hasSeq(xmlData, \"!--\",i) ) comment = true;\n                    else throw new Error(`Invalid DOCTYPE`);\n\n                    angleBracketsCount++;\n                    exp = \"\";\n                } else if (xmlData[i] === '>') { //Read tag content\n                    if(comment){\n                        if( xmlData[i - 1] === \"-\" && xmlData[i - 2] === \"-\"){\n                            comment = false;\n                            angleBracketsCount--;\n                        }\n                    }else{\n                        angleBracketsCount--;\n                    }\n                    if (angleBracketsCount === 0) {\n                    break;\n                    }\n                }else if( xmlData[i] === '['){\n                    hasBody = true;\n                }else{\n                    exp += xmlData[i];\n                }\n            }\n            if(angleBracketsCount !== 0){\n                throw new Error(`Unclosed DOCTYPE`);\n            }\n        }else{\n            throw new Error(`Invalid Tag instead of DOCTYPE`);\n        }\n        return {entities, i};\n    }\n    readEntityExp(xmlData, i) {    \n        //External entities are not supported\n        //    <!ENTITY ext SYSTEM \"http://normal-website.com\" >\n\n        //Parameter entities are not supported\n        //    <!ENTITY entityname \"&anotherElement;\">\n\n        //Internal entities are supported\n        //    <!ENTITY entityname \"replacement text\">\n\n        // Skip leading whitespace after <!ENTITY\n        i = skipWhitespace(xmlData, i);\n\n        // Read entity name\n        let entityName = \"\";\n        while (i < xmlData.length && !/\\s/.test(xmlData[i]) && xmlData[i] !== '\"' && xmlData[i] !== \"'\") {\n            entityName += xmlData[i];\n            i++;\n        }\n        validateEntityName(entityName);\n\n        // Skip whitespace after entity name\n        i = skipWhitespace(xmlData, i);\n\n        // Check for unsupported constructs (external entities or parameter entities)\n        if(!this.suppressValidationErr){\n            if (xmlData.substring(i, i + 6).toUpperCase() === \"SYSTEM\") {\n                throw new Error(\"External entities are not supported\");\n            }else if (xmlData[i] === \"%\") {\n                throw new Error(\"Parameter entities are not supported\");\n            }\n        }\n\n        // Read entity value (internal entity)\n        let entityValue = \"\";\n        [i, entityValue] = this.readIdentifierVal(xmlData, i, \"entity\");\n        i--;\n        return [entityName, entityValue, i ];\n    }\n\n    readNotationExp(xmlData, i) {\n        // Skip leading whitespace after <!NOTATION\n        i = skipWhitespace(xmlData, i);\n\n        // Read notation name\n        let notationName = \"\";\n        while (i < xmlData.length && !/\\s/.test(xmlData[i])) {\n            notationName += xmlData[i];\n            i++;\n        }\n        !this.suppressValidationErr && validateEntityName(notationName);\n\n        // Skip whitespace after notation name\n        i = skipWhitespace(xmlData, i);\n\n        // Check identifier type (SYSTEM or PUBLIC)\n        const identifierType = xmlData.substring(i, i + 6).toUpperCase();\n        if (!this.suppressValidationErr && identifierType !== \"SYSTEM\" && identifierType !== \"PUBLIC\") {\n            throw new Error(`Expected SYSTEM or PUBLIC, found \"${identifierType}\"`);\n        }\n        i += identifierType.length;\n\n        // Skip whitespace after identifier type\n        i = skipWhitespace(xmlData, i);\n\n        // Read public identifier (if PUBLIC)\n        let publicIdentifier = null;\n        let systemIdentifier = null;\n\n        if (identifierType === \"PUBLIC\") {\n            [i, publicIdentifier ] = this.readIdentifierVal(xmlData, i, \"publicIdentifier\");\n\n            // Skip whitespace after public identifier\n            i = skipWhitespace(xmlData, i);\n\n            // Optionally read system identifier\n            if (xmlData[i] === '\"' || xmlData[i] === \"'\") {\n                [i, systemIdentifier ] = this.readIdentifierVal(xmlData, i,\"systemIdentifier\");\n            }\n        } else if (identifierType === \"SYSTEM\") {\n            // Read system identifier (mandatory for SYSTEM)\n            [i, systemIdentifier ] = this.readIdentifierVal(xmlData, i, \"systemIdentifier\");\n\n            if (!this.suppressValidationErr && !systemIdentifier) {\n                throw new Error(\"Missing mandatory system identifier for SYSTEM notation\");\n            }\n        }\n        \n        return {notationName, publicIdentifier, systemIdentifier, index: --i};\n    }\n\n    readIdentifierVal(xmlData, i, type) {\n        let identifierVal = \"\";\n        const startChar = xmlData[i];\n        if (startChar !== '\"' && startChar !== \"'\") {\n            throw new Error(`Expected quoted string, found \"${startChar}\"`);\n        }\n        i++;\n\n        while (i < xmlData.length && xmlData[i] !== startChar) {\n            identifierVal += xmlData[i];\n            i++;\n        }\n\n        if (xmlData[i] !== startChar) {\n            throw new Error(`Unterminated ${type} value`);\n        }\n        i++;\n        return [i, identifierVal];\n    }\n\n    readElementExp(xmlData, i) {\n        // <!ELEMENT br EMPTY>\n        // <!ELEMENT div ANY>\n        // <!ELEMENT title (#PCDATA)>\n        // <!ELEMENT book (title, author+)>\n        // <!ELEMENT name (content-model)>\n        \n        // Skip leading whitespace after <!ELEMENT\n        i = skipWhitespace(xmlData, i);\n\n        // Read element name\n        let elementName = \"\";\n        while (i < xmlData.length && !/\\s/.test(xmlData[i])) {\n            elementName += xmlData[i];\n            i++;\n        }\n\n        // Validate element name\n        if (!this.suppressValidationErr && !isName(elementName)) {\n            throw new Error(`Invalid element name: \"${elementName}\"`);\n        }\n\n        // Skip whitespace after element name\n        i = skipWhitespace(xmlData, i);\n        let contentModel = \"\";\n        // Expect '(' to start content model\n        if(xmlData[i] === \"E\" && hasSeq(xmlData, \"MPTY\",i)) i+=4;\n        else if(xmlData[i] === \"A\" && hasSeq(xmlData, \"NY\",i)) i+=2;\n        else if (xmlData[i] === \"(\") {\n            i++; // Move past '('\n\n            // Read content model\n            while (i < xmlData.length && xmlData[i] !== \")\") {\n                contentModel += xmlData[i];\n                i++;\n            }\n            if (xmlData[i] !== \")\") {\n                throw new Error(\"Unterminated content model\");\n            }\n\n        }else if(!this.suppressValidationErr){\n            throw new Error(`Invalid Element Expression, found \"${xmlData[i]}\"`);\n        }\n        \n        return {\n            elementName,\n            contentModel: contentModel.trim(),\n            index: i\n        };\n    }\n\n    readAttlistExp(xmlData, i) {\n        // Skip leading whitespace after <!ATTLIST\n        i = skipWhitespace(xmlData, i);\n\n        // Read element name\n        let elementName = \"\";\n        while (i < xmlData.length && !/\\s/.test(xmlData[i])) {\n            elementName += xmlData[i];\n            i++;\n        }\n\n        // Validate element name\n        validateEntityName(elementName)\n\n        // Skip whitespace after element name\n        i = skipWhitespace(xmlData, i);\n\n        // Read attribute name\n        let attributeName = \"\";\n        while (i < xmlData.length && !/\\s/.test(xmlData[i])) {\n            attributeName += xmlData[i];\n            i++;\n        }\n\n        // Validate attribute name\n        if (!validateEntityName(attributeName)) {\n            throw new Error(`Invalid attribute name: \"${attributeName}\"`);\n        }\n\n        // Skip whitespace after attribute name\n        i = skipWhitespace(xmlData, i);\n\n        // Read attribute type\n        let attributeType = \"\";\n        if (xmlData.substring(i, i + 8).toUpperCase() === \"NOTATION\") {\n            attributeType = \"NOTATION\";\n            i += 8; // Move past \"NOTATION\"\n\n            // Skip whitespace after \"NOTATION\"\n            i = skipWhitespace(xmlData, i);\n\n            // Expect '(' to start the list of notations\n            if (xmlData[i] !== \"(\") {\n                throw new Error(`Expected '(', found \"${xmlData[i]}\"`);\n            }\n            i++; // Move past '('\n\n            // Read the list of allowed notations\n            let allowedNotations = [];\n            while (i < xmlData.length && xmlData[i] !== \")\") {\n                let notation = \"\";\n                while (i < xmlData.length && xmlData[i] !== \"|\" && xmlData[i] !== \")\") {\n                    notation += xmlData[i];\n                    i++;\n                }\n\n                // Validate notation name\n                notation = notation.trim();\n                if (!validateEntityName(notation)) {\n                    throw new Error(`Invalid notation name: \"${notation}\"`);\n                }\n\n                allowedNotations.push(notation);\n\n                // Skip '|' separator or exit loop\n                if (xmlData[i] === \"|\") {\n                    i++; // Move past '|'\n                    i = skipWhitespace(xmlData, i); // Skip optional whitespace after '|'\n                }\n            }\n\n            if (xmlData[i] !== \")\") {\n                throw new Error(\"Unterminated list of notations\");\n            }\n            i++; // Move past ')'\n\n            // Store the allowed notations as part of the attribute type\n            attributeType += \" (\" + allowedNotations.join(\"|\") + \")\";\n        } else {\n            // Handle simple types (e.g., CDATA, ID, IDREF, etc.)\n            while (i < xmlData.length && !/\\s/.test(xmlData[i])) {\n                attributeType += xmlData[i];\n                i++;\n            }\n\n            // Validate simple attribute type\n            const validTypes = [\"CDATA\", \"ID\", \"IDREF\", \"IDREFS\", \"ENTITY\", \"ENTITIES\", \"NMTOKEN\", \"NMTOKENS\"];\n            if (!this.suppressValidationErr && !validTypes.includes(attributeType.toUpperCase())) {\n                throw new Error(`Invalid attribute type: \"${attributeType}\"`);\n            }\n        }\n\n        // Skip whitespace after attribute type\n        i = skipWhitespace(xmlData, i);\n\n        // Read default value\n        let defaultValue = \"\";\n        if (xmlData.substring(i, i + 8).toUpperCase() === \"#REQUIRED\") {\n            defaultValue = \"#REQUIRED\";\n            i += 8;\n        } else if (xmlData.substring(i, i + 7).toUpperCase() === \"#IMPLIED\") {\n            defaultValue = \"#IMPLIED\";\n            i += 7;\n        } else {\n            [i, defaultValue] = this.readIdentifierVal(xmlData, i, \"ATTLIST\");\n        }\n\n        return {\n            elementName,\n            attributeName,\n            attributeType,\n            defaultValue,\n            index: i\n        }\n    }\n}\n\n\n\nconst skipWhitespace = (data, index) => {\n    while (index < data.length && /\\s/.test(data[index])) {\n        index++;\n    }\n    return index;\n};\n\n\n\nfunction hasSeq(data, seq,i){\n    for(let j=0;j<seq.length;j++){\n        if(seq[j]!==data[i+j+1]) return false;\n    }\n    return true;\n}\n\nfunction validateEntityName(name){\n    if (isName(name))\n\t    return name;\n    else\n        throw new Error(`Invalid entity name ${name}`);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}